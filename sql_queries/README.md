### Запросы к базе данных
Важно! Для SQLite >= 3.38
# sql_1
Напишите запрос, который выведет, сколько времени в среднем задачи каждой группы находятся в статусе “Open” 

Условия:
Под группой подразумевается первый символ в ключе задачи. Например, для ключа “C-40460” группой будет “C”
Задача может переходить в один и тот же статус несколько раз.
Переведите время в часы с округлением до двух знаков после запятой.

Что надо учесть:
- Некоторые значения поля ended_at пустые.
- Поскольку одна и та же задача может иметь статус Open несколько раз, то сначала надо просуммировать все время, что эта задача находится в статусе Open.

```sql
select substr(issue_key, 1, 1) as group_name,
	     round(avg(total_time) / 3600000, 2) as group_mean_time

from 

(select issue_key, sum(ended_at - started_at) as total_time
  from history
  where status='Open' AND (ended_at is not NULL)
  group by issue_key
)
    
group by group_name
order by group_mean_time desc
```

---
# sql_2
Напишите запрос, который выведет ключ задачи, последний статус и его время создания для задач, которые открыты на данный момент времени.

Условия:
Открытыми считаются задачи, у которых последний статус в момент времени не “Closed” и не “Resolved”
Задача может переходить в один и тот же статус несколько раз.
Оформите запрос таким образом, чтобы, изменив дату, его можно было использовать для поиска открытых задач в любой момент времени в прошлом
Переведите время в текстовое представление

Примечание! Как я понял, текстовое представление это из юникс метки преобразовать в обычный формат даты. Также преобразовал дату в тип "строка".

Что надо учесть:
- unixepoch доступна с 3.38 версии.
- для human_date надо использовать время в секундах.

```sql
select issue_key,
  	   status,
       human_date 

from

(select issue_key,
     		status,
     		max(started_at) as started_at,
     		cast(datetime(started_at / 1000,
                          'unixepoch') as text) as human_date
 from history
 where status not IN('Closed', 'Resolved')
 group by issue_key
)

where unixepoch(human_date) <= unixepoch('2023-01-11 01:11:11')
```
